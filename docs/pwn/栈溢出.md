# 栈溢出(上篇)

## 栈介绍

栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如图所示：

<img src=".\img\stack\栈结构.JPG" alt="栈结构" align='left' />

高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，**程序的栈是从进程地址空间的高地址向低地址增长的**。

## 函数调用栈

### 定义

函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量等。

称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。

函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。

<img src=".\img\stack\函数调用1.JPG" alt="函数调用1" align='left' style="zoom:80%;" />

### 相关寄存器：

ESP用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化

EBP用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置

EIP用来存储即将执行的程序指令的地址，cpu 依照 EIP的存储内容读取指令并执行，EIP随之指向相邻的下一条指令

### 调用过程

假设在Caller程序中调用Callee，将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态，过程如下(左边边为高地址)

Caller状态(高地址)——>Callee调用的参数(参数列表从右至左压入堆栈)——>将Caller调用Callee函数后的下一条指令压入堆栈，即返回地址——>将当前的ebp 寄存器的值（也就是调用函数的基地址）压入栈内，并将 ebp 寄存器的值更新为当前栈顶的地址——>被调用函数（callee）的局部变量等数据压入栈内

<img src=".\img\stack\函数调用栈情况.png" alt="函数调用栈情况" style="zoom:75%;" align='left'/>

其中压入堆栈的有调用参数、返回地址、调用函数的基地址、局部变量，而返回地址、调用函数的基地址和局部变量构成了被调用函数(Callee)的状态，每调用一个函数就构成一个状态栈，同时每返回一个函数就消除一个状态栈

### 返回过程

变化的核心任务是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态。

类似地，将栈中的元素出栈，先局部变量出栈，然后调用函数的基地址出栈，并存在esp寄存器中，调用函数（caller）的 ebp（基地址）信息得以恢复。其次是返回地址出栈，保存至eip寄存器，调用函数（caller）的eip信息恢复，调用函数Caller的状态恢复

<img src=".\img\stack\函数返回栈情况.png" alt="函数返回栈情况" style="zoom:75%;" align='left' />

## 栈溢出

要想实现攻击就必须拿到程序的控制权，而在函数内部执行的过程中，函数基本按照指令顺序在函数内部执行，我们无法进行控制，因此只有在函数调用或者结束函数调用的时候，程序的控制权才会在函数之间传递，这个时候我们可以尝试控制函数的状态来实现攻击，修改栈中的返回地址是最常用的手段。

而覆盖堆栈的技术包括以下几类：

+ 让返回地址指向溢出数据的一段指令（shellcode）
+ 让返回地址指向内存中已有的某个函数（return2libc）
+ 让返回地址指向内存中已有的一段指令（ROP）
+ 让某个被调用函数的地址指向另一个函数（hijack GOT）

### shellcode

在溢出数据中包含一段攻击指令，用攻击指令的地址覆盖掉函数的返回地址，当函数调用返回到攻击指令的位置后，执行指令获取shell，拿到程序的控制权，其中填充的shellcode是打开shell指令对应的机器码

前提：(1)函数调用栈中的数据要有可执行权限(2)关闭内存布局随机化

借助上述例子，payload : padding1 + address of shellcode + padding2 + shellcode

<img src=".\img\stack\shellcode 所用溢出数据的最终构造.png" alt="shellcode 所用溢出数据的最终构造" style="zoom:75%;" align="left" />

其中padding1的长度是可输入地址距离返回地址的偏移量，Address of shellcode表示栈中shellcode指令的地址，由于调试工具中运行的地址与实际运行时的地址不一致，这只能大致确定shellcode的范围，故解决办法是往返回地址后面填充\x90，机器码对应指令NOP，作用是让CPU跳到下一条指令，即什么都不做。故只需要返回地址命中这一段就能跳到shellcode指令的位置处，这种方法称为 NOP Sled（滑雪橇）

当然还可以利用另一种方法，当操作系统关闭了内存布局随机化（ASLR），程序每次运行时函数返回地址会是相同的，这样我们可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定 shellcode 的起始地址

